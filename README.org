#+title: Clojure Web App

Building web applications with Clojure can be productive and fun, assuming
you're familiar with the underlying protocols and technologies of the web.

#+begin_src sh :results output verbatim :exports both :wrap src html
curl http://localhost:3000/ | htmlq h1
#+end_src

#+results:
#+begin_src html
<h1 class="mt-2 text-4xl font-semibold tracking-tight text-gray-900 sm:text-6xl">Coming soon!</h1>
#+end_src

* What's in the box?
We have a collection of bin scripts to package up common tasks:

- =bin/create-migration=: Create =up= and =down= files for SQL-based schema migrations
- =bin/lint=: Spot issues and critique style according to subjective sensibilities
- =bin/nrepl=: Start an nREPL server (best invoked via =devenv=)
- =bin/tailwind=: Run a Tailwind process to watch for use of TailwindCSS classes
- =bin/test=: Run tests (assuming PostgreSQL is available)

#+begin_src sh :results output verbatim :exports results
tree -I node_modules
#+end_src

#+results:
#+begin_example
.
├── README.org
├── bin
│   ├── create-migration
│   ├── lint
│   ├── nrepl
│   ├── tailwind
│   └── test
├── deps.edn
├── dev
│   ├── user.clj
│   └── web
│       ├── db.clj
│       ├── dev.clj
│       └── nrepl.clj
├── dev-resources
│   └── logback.xml
├── devenv.lock
├── devenv.nix
├── devenv.yaml
├── docker
│   ├── Dockerfile.postgres
│   └── init.sql
├── docker-compose.yml
├── package.json
├── pnpm-lock.yaml
├── resources
│   ├── migrations
│   │   ├── 20250314165829-create-schema.down.sql
│   │   └── 20250314165829-create-schema.up.sql
│   └── public
│       ├── android-chrome-192x192.png
│       ├── android-chrome-512x512.png
│       ├── app.css
│       ├── app.js
│       ├── apple-touch-icon.png
│       ├── favicon-16x16.png
│       ├── favicon-32x32.png
│       ├── favicon.ico
│       └── js
│           ├── htmx-ext-preload@2.1.0.js
│           └── htmx@2.0.3.min.js
├── src
│   └── web
│       ├── assets.clj
│       ├── concierge.clj
│       ├── config.clj
│       ├── interceptors.clj
│       ├── page.clj
│       ├── postgres
│       │   ├── employment.clj
│       │   ├── group.clj
│       │   ├── organization.clj
│       │   ├── user.clj
│       │   └── verified_domain.clj
│       ├── postgres.clj
│       ├── router.clj
│       ├── service
│       │   ├── manifest.clj
│       │   └── root.clj
│       ├── service.clj
│       ├── spec.clj
│       ├── string.clj
│       ├── system.clj
│       └── ui.clj
├── styles
│   └── tailwind.css
├── tailwind.config.cjs
├── test
│   └── web
│       ├── postgres_test.clj
│       ├── service_test.clj
│       └── test
│           ├── hooks.clj
│           ├── html.clj
│           ├── service.clj
│           └── system.clj
└── tests.edn

18 directories, 60 files
#+end_example

* Development
** With Nix and =devenv=
The easiest way to start a development environment is via Nix and devenv:

#+begin_src sh :eval never
devenv up
#+end_src

** With Docker et al
Start PostgreSQL as per your preference and provide a database URL to the nREPL
server process like so:

#+begin_src sh :eval never
DATABASE_URL='jdbc:postgresql://127.0.0.1:5432/web_dev?user=web&password=please' \
  bin/nrepl
#+end_src

For convenience, we provide a Docker Compose file that will run PostgreSQL
locally for those who prefer containers.

* Coding task
As part of our customer activation process, we need to insert new organizations
and their members into our PostgreSQL database.

The suggested format for representing organizations looks like this:

#+begin_src clojure
{"flowstate.inc"
 {:web.postgres.organization/name             "flowstate"
  :web.postgres.organization/verified-domains #{"flowstate.inc"}
  :web.postgres.organization/members          #{{:web.postgres.user/email     "user-0@flowstate.inc"}
                                                {:web.postgres.user/email     "user-1@flowstate.inc"}
                                                {:web.postgres.user/email     "user-2@flowstate.inc"}}}

 "example.com"
 {:web.postgres.organization/name             "Example"
  :web.postgres.organization/verified-domains #{"example.com" "example.dev"}
  :web.postgres.organization/members          #{{:web.postgres.user/email     "user-0@example.com"}
                                                {:web.postgres.user/email     "user-1@example.com"}
                                                {:web.postgres.user/email     "user-2@example.dev"}}}}
#+end_src

The following events are likely to occur in future and we need to support them:

1. We will add new organizations
2. We need to be able to add and remove verified domains
3. We will add new members to organizations
4. We may remove organizations members
5. It's possible a user's email address might change

Please do not worry about validation of the data. Assume it is well-formed and
without error (e.g. users will always have email addresses).

You can use an alternate representation, include additional information and
replace any names as you see fit (hint: adding additional information will
greatly simplify the task).

The following relationships exist within the database:

- Organizations have zero or more verified domains
- Organizations have many employments
- Users have many organizations through their employments
- Users have many groups through their group memberships
- Groups belong to an organization

Organizations and their members will not exist prior to the first invocation of
your activation process.

Some considerations to keep in mind:

- The process of activating organizations must be idempotent.
- The existing =web.concierge= namespace is a good place to add your activation
  logic.
- You can make changes to the database and have full control over all of the
  data within it.
- We must be careful to not lose any data that would negatively impact customer
  experience or the flowstate brand.
- We can be pragmatic with our approach and ask the supplier of this EDN file to
  adhere to certain justifiable constraints.

Any code we produce needs automated tests. Refactoring parts of the code base is
fine as long as we're working towards delivering working software.

We're interested in your approach to problem solving, how you think about
crafting software, and how you make trade-offs where necessary. You can use
language models, search engines, your preferred editor and operating system. We
only ask that you pair with us on solving the problem with Clojure.
